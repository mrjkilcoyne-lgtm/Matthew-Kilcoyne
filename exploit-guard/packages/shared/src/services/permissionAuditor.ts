import type { AppPermission, AppRiskProfile, AppBehavior } from '../models/types';

// Permission danger classifications
const DANGEROUS_PERMISSIONS: Record<string, { category: AppPermission['category']; description: string }> = {
  'camera': { category: 'CAMERA', description: 'Access device camera to take photos and videos' },
  'microphone': { category: 'MICROPHONE', description: 'Record audio through the device microphone' },
  'geolocation': { category: 'LOCATION', description: 'Track precise device location via GPS' },
  'notifications': { category: 'OTHER', description: 'Send push notifications to the device' },
  'clipboard-read': { category: 'OTHER', description: 'Read clipboard contents (passwords, links)' },
  'clipboard-write': { category: 'OTHER', description: 'Write to device clipboard' },
  'persistent-storage': { category: 'STORAGE', description: 'Store data persistently on the device' },
  'midi': { category: 'OTHER', description: 'Access MIDI devices' },
  'screen-wake-lock': { category: 'OTHER', description: 'Prevent screen from sleeping' },
  'accelerometer': { category: 'OTHER', description: 'Access motion sensors' },
  'gyroscope': { category: 'OTHER', description: 'Access orientation sensors' },
  'magnetometer': { category: 'OTHER', description: 'Access magnetic field sensor' },
  'ambient-light-sensor': { category: 'OTHER', description: 'Detect ambient light levels' },
  'bluetooth': { category: 'OTHER', description: 'Access Bluetooth devices' },
  'usb': { category: 'OTHER', description: 'Access USB devices' },
  'serial': { category: 'OTHER', description: 'Access serial ports' },
  'hid': { category: 'OTHER', description: 'Access human interface devices' },
};

// Known stalkerware package identifiers and behaviors
const STALKERWARE_INDICATORS = [
  'spy', 'track', 'monitor', 'stealth', 'hidden', 'invisible',
  'keylog', 'sms.tracker', 'call.recorder', 'phone.tracker',
  'gps.tracker', 'family.tracker', 'parental.control',
];

/**
 * Audit browser/web permissions
 */
export async function auditWebPermissions(): Promise<AppPermission[]> {
  const permissions: AppPermission[] = [];

  if (typeof navigator === 'undefined' || !navigator.permissions) {
    return permissions;
  }

  const permNames = Object.keys(DANGEROUS_PERMISSIONS);

  for (const name of permNames) {
    try {
      const result = await navigator.permissions.query({ name: name as PermissionName });
      const info = DANGEROUS_PERMISSIONS[name];
      permissions.push({
        name,
        description: info.description,
        dangerLevel: ['camera', 'microphone', 'geolocation', 'clipboard-read'].includes(name) ? 'DANGEROUS' : 'NORMAL',
        granted: result.state === 'granted',
        category: info.category,
      });
    } catch {
      // Permission not supported in this browser
    }
  }

  return permissions;
}

/**
 * Calculate risk score for an app based on its permissions
 */
export function calculateAppRiskScore(permissions: AppPermission[], behaviors: AppBehavior[]): number {
  let score = 0;

  // Permission-based risk
  const dangerousGranted = permissions.filter((p) => p.dangerLevel === 'DANGEROUS' && p.granted);
  score += dangerousGranted.length * 10;

  // Camera + Microphone together is high risk
  const hasCamera = permissions.some((p) => p.category === 'CAMERA' && p.granted);
  const hasMic = permissions.some((p) => p.category === 'MICROPHONE' && p.granted);
  if (hasCamera && hasMic) score += 15;

  // Location is always concerning
  if (permissions.some((p) => p.category === 'LOCATION' && p.granted)) score += 10;

  // Behavior-based risk
  for (const behavior of behaviors) {
    switch (behavior.severity) {
      case 'DANGER':
        score += 20;
        break;
      case 'WARNING':
        score += 10;
        break;
      case 'INFO':
        score += 2;
        break;
    }
  }

  return Math.min(score, 100);
}

/**
 * Check if an app name/package matches stalkerware patterns
 */
export function checkStalkerwareIndicators(packageName: string, appName: string): boolean {
  const combined = `${packageName} ${appName}`.toLowerCase();
  return STALKERWARE_INDICATORS.some((indicator) => combined.includes(indicator));
}

/**
 * Analyze an app profile for stalkerware characteristics
 */
export function analyzeStalkerwareBehaviors(profile: Partial<AppRiskProfile>): AppBehavior[] {
  const behaviors: AppBehavior[] = [];
  const permissions = profile.permissions || [];

  // Hidden from launcher
  if (profile.appName === '' || profile.appName?.includes('System Service')) {
    behaviors.push({
      type: 'DEVICE_ADMIN',
      description: 'App disguises itself as a system service',
      severity: 'DANGER',
    });
  }

  // Suspicious permission combinations
  const hasSMS = permissions.some((p) => p.category === 'SMS' && p.granted);
  const hasPhone = permissions.some((p) => p.category === 'PHONE' && p.granted);
  const hasLocation = permissions.some((p) => p.category === 'LOCATION' && p.granted);
  const hasCamera = permissions.some((p) => p.category === 'CAMERA' && p.granted);
  const hasMic = permissions.some((p) => p.category === 'MICROPHONE' && p.granted);
  const hasContacts = permissions.some((p) => p.category === 'CONTACTS' && p.granted);

  if (hasSMS && hasPhone && hasLocation) {
    behaviors.push({
      type: 'DATA_COLLECTION',
      description: 'App has access to SMS, phone calls, and location - common stalkerware pattern',
      severity: 'DANGER',
    });
  }

  if (hasCamera && hasMic && hasLocation) {
    behaviors.push({
      type: 'DATA_COLLECTION',
      description: 'App can record audio/video and track location simultaneously',
      severity: 'WARNING',
    });
  }

  if (hasContacts && hasSMS) {
    behaviors.push({
      type: 'DATA_COLLECTION',
      description: 'App can read contacts and SMS messages',
      severity: 'WARNING',
    });
  }

  // Check network activity
  if (profile.networkActivity && profile.networkActivity.length > 0) {
    const uniqueHosts = new Set(profile.networkActivity.map((c) => c.remoteHost));
    if (uniqueHosts.size > 10) {
      behaviors.push({
        type: 'NETWORK_TRAFFIC',
        description: `App communicates with ${uniqueHosts.size} different servers`,
        severity: 'WARNING',
      });
    }
  }

  return behaviors;
}

/**
 * Get risk level label from score
 */
export function getRiskLevel(score: number): AppRiskProfile['riskLevel'] {
  if (score >= 80) return 'DANGEROUS';
  if (score >= 60) return 'HIGH';
  if (score >= 40) return 'MEDIUM';
  if (score >= 20) return 'LOW';
  return 'SAFE';
}

/**
 * Generate permission audit summary
 */
export function generatePermissionSummary(permissions: AppPermission[]): {
  totalPermissions: number;
  dangerousCount: number;
  grantedCount: number;
  categories: Record<string, number>;
} {
  const categories: Record<string, number> = {};
  permissions.forEach((p) => {
    if (p.granted) {
      categories[p.category] = (categories[p.category] || 0) + 1;
    }
  });

  return {
    totalPermissions: permissions.length,
    dangerousCount: permissions.filter((p) => p.dangerLevel === 'DANGEROUS').length,
    grantedCount: permissions.filter((p) => p.granted).length,
    categories,
  };
}
