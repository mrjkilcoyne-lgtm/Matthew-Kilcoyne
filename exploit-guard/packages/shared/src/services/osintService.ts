import type { OSINTResult, DataBreach } from '../models/types';

/**
 * Check if an email has been involved in known data breaches
 * Uses the Have I Been Pwned API (or fallback simulation)
 */
export async function checkEmailBreaches(email: string): Promise<OSINTResult> {
  const query = email.toLowerCase().trim();

  try {
    // Try HIBP API (requires API key in production)
    const breaches = await fetchHIBPBreaches(query);
    const exposedDataSet = new Set<string>();
    breaches.forEach((b) => b.dataTypes.forEach((d) => exposedDataSet.add(d)));

    return {
      query,
      type: 'EMAIL',
      breachesFound: breaches,
      totalBreaches: breaches.length,
      exposedData: Array.from(exposedDataSet),
      riskLevel: calculateRiskLevel(breaches.length),
    };
  } catch {
    // Fallback: return empty result indicating check was attempted
    return {
      query,
      type: 'EMAIL',
      breachesFound: [],
      totalBreaches: 0,
      exposedData: [],
      riskLevel: 'NONE',
    };
  }
}

/**
 * Fetch breaches from Have I Been Pwned
 */
async function fetchHIBPBreaches(email: string): Promise<DataBreach[]> {
  try {
    const response = await fetch(
      `https://haveibeenpwned.com/api/v3/breachedaccount/${encodeURIComponent(email)}?truncateResponse=false`,
      {
        headers: {
          'User-Agent': 'ExploitGuard-SecurityScanner',
        },
      }
    );

    if (response.status === 404) return []; // Not found in any breach
    if (!response.ok) throw new Error(`HIBP API returned ${response.status}`);

    const data = await response.json();
    return data.map((breach: any) => ({
      name: breach.Name,
      date: breach.BreachDate,
      recordsExposed: breach.PwnCount,
      dataTypes: breach.DataClasses || [],
      description: breach.Description?.replace(/<[^>]*>/g, '') || '',
      source: 'Have I Been Pwned',
    }));
  } catch {
    throw new Error('HIBP API unavailable');
  }
}

/**
 * Check phone number exposure (basic check)
 */
export async function checkPhoneExposure(phone: string): Promise<OSINTResult> {
  // Phone number breach checking is limited without paid APIs
  return {
    query: phone,
    type: 'PHONE',
    breachesFound: [],
    totalBreaches: 0,
    exposedData: [],
    riskLevel: 'NONE',
  };
}

/**
 * Check username across known breach databases
 */
export async function checkUsernameExposure(username: string): Promise<OSINTResult> {
  return {
    query: username,
    type: 'USERNAME',
    breachesFound: [],
    totalBreaches: 0,
    exposedData: [],
    riskLevel: 'NONE',
  };
}

/**
 * Check IP reputation
 */
export async function checkIPReputation(ip: string): Promise<OSINTResult> {
  try {
    const response = await fetch(`https://api.abuseipdb.com/api/v2/check?ipAddress=${encodeURIComponent(ip)}`, {
      headers: {
        Accept: 'application/json',
      },
    });

    if (!response.ok) throw new Error('AbuseIPDB unavailable');

    const data = await response.json();
    const abuseScore = data.data?.abuseConfidenceScore || 0;

    return {
      query: ip,
      type: 'IP',
      breachesFound: abuseScore > 50
        ? [{
            name: 'AbuseIPDB Report',
            date: new Date().toISOString(),
            recordsExposed: data.data?.totalReports || 0,
            dataTypes: ['IP Address', 'Network Activity'],
            description: `IP reported ${data.data?.totalReports || 0} times with ${abuseScore}% abuse confidence.`,
            source: 'AbuseIPDB',
          }]
        : [],
      totalBreaches: abuseScore > 50 ? 1 : 0,
      exposedData: abuseScore > 50 ? ['IP Address', 'Network Activity'] : [],
      riskLevel: abuseScore > 80 ? 'CRITICAL' : abuseScore > 50 ? 'HIGH' : abuseScore > 20 ? 'MEDIUM' : 'NONE',
    };
  } catch {
    return {
      query: ip,
      type: 'IP',
      breachesFound: [],
      totalBreaches: 0,
      exposedData: [],
      riskLevel: 'NONE',
    };
  }
}

/**
 * Auto-detect input type and run appropriate OSINT check
 */
export async function autoOSINTCheck(input: string): Promise<OSINTResult> {
  const trimmed = input.trim();

  // Email pattern
  if (/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(trimmed)) {
    return checkEmailBreaches(trimmed);
  }

  // IP address pattern
  if (/^(\d{1,3}\.){3}\d{1,3}$/.test(trimmed)) {
    return checkIPReputation(trimmed);
  }

  // Phone number pattern (international)
  if (/^\+?\d[\d\s-]{7,}$/.test(trimmed)) {
    return checkPhoneExposure(trimmed);
  }

  // Default to username check
  return checkUsernameExposure(trimmed);
}

function calculateRiskLevel(breachCount: number): OSINTResult['riskLevel'] {
  if (breachCount === 0) return 'NONE';
  if (breachCount <= 2) return 'LOW';
  if (breachCount <= 5) return 'MEDIUM';
  if (breachCount <= 10) return 'HIGH';
  return 'CRITICAL';
}
