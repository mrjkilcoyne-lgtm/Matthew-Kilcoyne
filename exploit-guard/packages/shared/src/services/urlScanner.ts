import type { URLScanResult } from '../models/types';

// Known phishing/malware domains (sample blocklist)
const BLOCKLIST_DOMAINS = new Set([
  'secure-login-verify.com',
  'account-recovery-help.net',
  'free-prize-winner.com',
  'update-your-password.org',
  'urgent-security-alert.com',
  'bank-verification-required.net',
  'paypal-secure-login.info',
  'apple-id-confirm.com',
  'microsoft-support-alert.com',
  'amazon-order-confirm.net',
]);

// Suspicious TLD patterns
const SUSPICIOUS_TLDS = ['.xyz', '.top', '.buzz', '.gq', '.ml', '.tk', '.cf', '.ga', '.work', '.click', '.loan', '.racing'];

// Legitimate shortened URL domains
const URL_SHORTENERS = ['bit.ly', 'tinyurl.com', 't.co', 'goo.gl', 'is.gd', 'buff.ly', 'ow.ly', 'rebrand.ly'];

/**
 * Perform a comprehensive URL safety scan
 */
export async function scanURL(inputUrl: string): Promise<URLScanResult> {
  const normalizedUrl = normalizeUrl(inputUrl);
  const scanDate = new Date().toISOString();

  try {
    const urlObj = new URL(normalizedUrl);
    const domain = urlObj.hostname.toLowerCase();

    // Check against blocklist
    if (BLOCKLIST_DOMAINS.has(domain)) {
      return {
        url: normalizedUrl,
        isSafe: false,
        threatType: 'PHISHING',
        riskScore: 95,
        sslValid: false,
        redirectChain: [],
        scanDate,
      };
    }

    // Domain age and reputation checks
    const riskFactors: string[] = [];
    let riskScore = 0;

    // Check suspicious TLDs
    if (SUSPICIOUS_TLDS.some((tld) => domain.endsWith(tld))) {
      riskFactors.push('Suspicious TLD');
      riskScore += 20;
    }

    // Check for URL shortener
    if (URL_SHORTENERS.some((s) => domain === s || domain.endsWith(`.${s}`))) {
      riskFactors.push('URL shortener (could mask destination)');
      riskScore += 10;
    }

    // Check for IP address instead of domain
    if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(domain)) {
      riskFactors.push('IP address used instead of domain name');
      riskScore += 25;
    }

    // Check for excessive subdomains (homograph attack indicator)
    const subdomainCount = domain.split('.').length - 2;
    if (subdomainCount > 2) {
      riskFactors.push('Excessive subdomains');
      riskScore += 15;
    }

    // Check for lookalike domain patterns
    const lookalikeBrands = ['paypal', 'google', 'apple', 'microsoft', 'amazon', 'facebook', 'netflix', 'instagram', 'whatsapp', 'telegram'];
    for (const brand of lookalikeBrands) {
      if (domain.includes(brand) && !domain.endsWith(`.${brand}.com`) && domain !== `${brand}.com` && domain !== `www.${brand}.com`) {
        riskFactors.push(`Possible ${brand} impersonation`);
        riskScore += 30;
        break;
      }
    }

    // Check for punycode / IDN homograph
    if (domain.startsWith('xn--')) {
      riskFactors.push('Internationalized domain (possible homograph attack)');
      riskScore += 20;
    }

    // Check HTTPS
    const sslValid = urlObj.protocol === 'https:';
    if (!sslValid) {
      riskFactors.push('No HTTPS encryption');
      riskScore += 15;
    }

    // Check for suspicious path patterns
    const suspiciousPathPatterns = ['/wp-admin', '/login', '/signin', '/verify', '/confirm', '/secure', '/update', '/account'];
    if (suspiciousPathPatterns.some((p) => urlObj.pathname.toLowerCase().includes(p))) {
      riskScore += 5;
    }

    // Try WHOIS lookup via RDAP
    let whoisData: { registrar?: string; created?: string; country?: string } = {};
    try {
      whoisData = await fetchRDAPInfo(domain);
    } catch {
      // RDAP lookup failed, continue without it
    }

    // Calculate domain age risk
    let domainAge: number | undefined;
    if (whoisData.created) {
      const createdDate = new Date(whoisData.created);
      domainAge = Math.floor((Date.now() - createdDate.getTime()) / (1000 * 60 * 60 * 24));
      if (domainAge < 30) {
        riskFactors.push('Domain registered less than 30 days ago');
        riskScore += 25;
      } else if (domainAge < 90) {
        riskFactors.push('Domain registered less than 90 days ago');
        riskScore += 10;
      }
    }

    // Cap risk score
    riskScore = Math.min(riskScore, 100);

    // Determine threat type
    let threatType: URLScanResult['threatType'];
    if (riskScore >= 70) threatType = 'PHISHING';
    else if (riskScore >= 50) threatType = 'SUSPICIOUS';
    else if (riskScore >= 30) threatType = 'SPAM';

    // SSL info (basic)
    let sslIssuer: string | undefined;
    let sslExpiry: string | undefined;
    if (sslValid) {
      try {
        const sslInfo = await checkSSLInfo(normalizedUrl);
        sslIssuer = sslInfo.issuer;
        sslExpiry = sslInfo.expiry;
      } catch {
        // SSL check failed
      }
    }

    return {
      url: normalizedUrl,
      isSafe: riskScore < 30,
      threatType,
      riskScore,
      sslValid,
      sslIssuer,
      sslExpiry,
      whoisRegistrar: whoisData.registrar,
      whoisCreated: whoisData.created,
      whoisCountry: whoisData.country,
      domainAge,
      redirectChain: [],
      scanDate,
    };
  } catch {
    return {
      url: inputUrl,
      isSafe: false,
      threatType: 'SUSPICIOUS',
      riskScore: 50,
      sslValid: false,
      redirectChain: [],
      scanDate,
    };
  }
}

/**
 * Normalize a URL input
 */
function normalizeUrl(input: string): string {
  let url = input.trim();
  if (!/^https?:\/\//i.test(url)) {
    url = `https://${url}`;
  }
  return url;
}

/**
 * Fetch RDAP (Registration Data Access Protocol) info for a domain
 */
async function fetchRDAPInfo(domain: string): Promise<{ registrar?: string; created?: string; country?: string }> {
  const tld = domain.split('.').pop();
  try {
    const bootstrapRes = await fetch('https://data.iana.org/rdap/dns.json');
    const bootstrap = await bootstrapRes.json();
    let rdapBase = '';
    for (const service of bootstrap.services) {
      if (service[0].includes(tld)) {
        rdapBase = service[1][0];
        break;
      }
    }
    if (!rdapBase) return {};
    const rdapRes = await fetch(`${rdapBase}domain/${domain}`);
    if (!rdapRes.ok) return {};
    const rdapData = await rdapRes.json();
    const registrar = rdapData.entities?.find((e: any) => e.roles?.includes('registrar'))?.vcardArray?.[1]?.find((v: any) => v[0] === 'fn')?.[3];
    const created = rdapData.events?.find((e: any) => e.eventAction === 'registration')?.eventDate;
    return { registrar, created };
  } catch {
    return {};
  }
}

/**
 * Basic SSL certificate info check
 */
async function checkSSLInfo(_url: string): Promise<{ issuer?: string; expiry?: string }> {
  // In a browser context, detailed SSL info isn't available via fetch
  // This would be implemented natively on mobile/desktop
  return {};
}

/**
 * Batch scan multiple URLs
 */
export async function batchScanURLs(urls: string[]): Promise<URLScanResult[]> {
  return Promise.all(urls.map(scanURL));
}

/**
 * Check if a URL is a known URL shortener
 */
export function isURLShortener(url: string): boolean {
  try {
    const domain = new URL(normalizeUrl(url)).hostname.toLowerCase();
    return URL_SHORTENERS.some((s) => domain === s || domain.endsWith(`.${s}`));
  } catch {
    return false;
  }
}
