import type { FileScanResult } from '../models/types';

/**
 * Calculate SHA-256 hash of a file (browser-compatible)
 */
export async function hashFile(file: File): Promise<{ md5: string; sha1: string; sha256: string }> {
  const buffer = await file.arrayBuffer();

  // SHA-256 via Web Crypto API
  const sha256Buffer = await crypto.subtle.digest('SHA-256', buffer);
  const sha256 = bufferToHex(sha256Buffer);

  // SHA-1 via Web Crypto API
  const sha1Buffer = await crypto.subtle.digest('SHA-1', buffer);
  const sha1 = bufferToHex(sha1Buffer);

  // MD5 is not available in Web Crypto API, compute a simple checksum instead
  const md5 = computeSimpleHash(new Uint8Array(buffer));

  return { md5, sha1, sha256 };
}

function bufferToHex(buffer: ArrayBuffer): string {
  return Array.from(new Uint8Array(buffer))
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}

/**
 * Simple non-cryptographic hash as MD5 fallback for web
 */
function computeSimpleHash(data: Uint8Array): string {
  let hash = 0x811c9dc5;
  for (let i = 0; i < data.length; i++) {
    hash ^= data[i];
    hash = Math.imul(hash, 0x01000193);
  }
  return (hash >>> 0).toString(16).padStart(8, '0');
}

/**
 * Known malware file hashes (sample database)
 */
const KNOWN_MALWARE_HASHES = new Set([
  // These are example hashes - in production, this would query VirusTotal or similar
  'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855', // empty file
]);

/**
 * Suspicious file extensions
 */
const SUSPICIOUS_EXTENSIONS = new Set([
  '.exe', '.bat', '.cmd', '.com', '.vbs', '.vbe', '.js', '.jse',
  '.wsf', '.wsh', '.ps1', '.psc1', '.scr', '.pif', '.msi', '.msp',
  '.mst', '.cpl', '.hta', '.inf', '.ins', '.isp', '.reg', '.rgs',
  '.sct', '.shb', '.shs', '.ws', '.apk', '.dex', '.jar',
]);

/**
 * Scan a file for potential threats
 */
export async function scanFile(file: File): Promise<FileScanResult> {
  const hashes = await hashFile(file);
  const detections: string[] = [];
  let isMalicious = false;

  // Check against known malware hashes
  if (KNOWN_MALWARE_HASHES.has(hashes.sha256)) {
    detections.push('Known malware hash detected');
    isMalicious = true;
  }

  // Check file extension
  const extension = getFileExtension(file.name).toLowerCase();
  if (SUSPICIOUS_EXTENSIONS.has(extension)) {
    detections.push(`Suspicious file type: ${extension}`);
  }

  // Check for double extensions (e.g., document.pdf.exe)
  const parts = file.name.split('.');
  if (parts.length > 2) {
    const lastExt = `.${parts[parts.length - 1].toLowerCase()}`;
    const secondLastExt = `.${parts[parts.length - 2].toLowerCase()}`;
    if (SUSPICIOUS_EXTENSIONS.has(lastExt) && !SUSPICIOUS_EXTENSIONS.has(secondLastExt)) {
      detections.push('Double extension detected - possible disguised executable');
      isMalicious = true;
    }
  }

  // Check for unusually large files
  if (file.size > 100 * 1024 * 1024) {
    detections.push('Unusually large file (>100MB)');
  }

  // Check for zero-byte files
  if (file.size === 0) {
    detections.push('Empty file (0 bytes)');
  }

  // Basic content analysis for text-based files
  if (file.type.startsWith('text/') || extension === '.js' || extension === '.html') {
    try {
      const text = await file.text();
      const suspiciousPatterns = analyzeTextContent(text);
      detections.push(...suspiciousPatterns);
      if (suspiciousPatterns.some((p) => p.includes('obfuscated') || p.includes('eval'))) {
        isMalicious = true;
      }
    } catch {
      // Could not read file as text
    }
  }

  // Try VirusTotal lookup (requires API key)
  let vtResult: { scanEngines: number; positiveDetections: number } = { scanEngines: 0, positiveDetections: 0 };
  try {
    vtResult = await checkVirusTotal(hashes.sha256);
    if (vtResult.positiveDetections > 0) {
      detections.push(`VirusTotal: ${vtResult.positiveDetections}/${vtResult.scanEngines} engines detected threats`);
      isMalicious = true;
    }
  } catch {
    // VirusTotal unavailable
  }

  return {
    fileName: file.name,
    fileSize: file.size,
    fileHash: hashes,
    isMalicious,
    detections,
    scanEngines: vtResult.scanEngines,
    positiveDetections: vtResult.positiveDetections,
    scanDate: new Date().toISOString(),
  };
}

/**
 * Analyze text file content for suspicious patterns
 */
function analyzeTextContent(text: string): string[] {
  const findings: string[] = [];

  // Check for eval/exec patterns
  if (/\beval\s*\(/i.test(text)) {
    findings.push('Contains eval() - potential code injection');
  }

  // Check for base64-encoded content
  if (/[A-Za-z0-9+/]{50,}={0,2}/.test(text)) {
    findings.push('Contains long base64-encoded string');
  }

  // Check for heavily obfuscated code
  if (/\\x[0-9a-f]{2}/gi.test(text) && (text.match(/\\x[0-9a-f]{2}/gi) || []).length > 20) {
    findings.push('Contains obfuscated hex-encoded content');
  }

  // Check for suspicious URLs
  if (/https?:\/\/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/i.test(text)) {
    findings.push('Contains URLs with IP addresses instead of domains');
  }

  // Check for PowerShell commands
  if (/powershell|invoke-expression|iex|downloadstring|invoke-webrequest/i.test(text)) {
    findings.push('Contains PowerShell command references');
  }

  return findings;
}

/**
 * Check file hash against VirusTotal (requires API key)
 */
async function checkVirusTotal(sha256: string): Promise<{ scanEngines: number; positiveDetections: number }> {
  const apiKey = typeof process !== 'undefined' ? process.env?.VIRUSTOTAL_API_KEY : undefined;
  if (!apiKey) return { scanEngines: 0, positiveDetections: 0 };

  const response = await fetch(`https://www.virustotal.com/api/v3/files/${sha256}`, {
    headers: { 'x-apikey': apiKey },
  });

  if (!response.ok) return { scanEngines: 0, positiveDetections: 0 };

  const data = await response.json();
  const stats = data.data?.attributes?.last_analysis_stats || {};
  return {
    scanEngines: Object.values(stats).reduce((a: number, b: any) => a + (b as number), 0),
    positiveDetections: (stats.malicious || 0) + (stats.suspicious || 0),
  };
}

function getFileExtension(filename: string): string {
  const lastDot = filename.lastIndexOf('.');
  return lastDot >= 0 ? filename.substring(lastDot) : '';
}
